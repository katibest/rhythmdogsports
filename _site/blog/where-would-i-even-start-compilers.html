<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Where Would I Even Start Compilers | Rhythm Dog Sports</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Where Would I Even Start Compilers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Compilers are scary…at least from the outside. On the inside, though, the basics of a compiler are a lot simpler than you may think. A compiler is really just a program to convert between languages. For example, the Babel compiler converts newer versions of JavaScript to older versions that are more compatible with today’s browsers. The things that make larger compilers so menacing are complicated, ambiguous language designs, large standard libraries, and performance optimizations, just to name a few." />
<meta property="og:description" content="Compilers are scary…at least from the outside. On the inside, though, the basics of a compiler are a lot simpler than you may think. A compiler is really just a program to convert between languages. For example, the Babel compiler converts newer versions of JavaScript to older versions that are more compatible with today’s browsers. The things that make larger compilers so menacing are complicated, ambiguous language designs, large standard libraries, and performance optimizations, just to name a few." />
<link rel="canonical" href="http://localhost:4000/blog/where-would-i-even-start-compilers" />
<meta property="og:url" content="http://localhost:4000/blog/where-would-i-even-start-compilers" />
<meta property="og:site_name" content="Rhythm Dog Sports" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-02T00:00:00-04:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/blog/where-would-i-even-start-compilers","headline":"Where Would I Even Start Compilers","dateModified":"2019-07-02T00:00:00-04:00","datePublished":"2019-07-02T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/where-would-i-even-start-compilers"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo.png"}},"description":"Compilers are scary…at least from the outside. On the inside, though, the basics of a compiler are a lot simpler than you may think. A compiler is really just a program to convert between languages. For example, the Babel compiler converts newer versions of JavaScript to older versions that are more compatible with today’s browsers. The things that make larger compilers so menacing are complicated, ambiguous language designs, large standard libraries, and performance optimizations, just to name a few.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="https://use.typekit.net/vnr4ouz.css">
    <link href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  </head>
  <body>
    <nav>
  <a class="nav__logo" href="/"></a>
  <input type="checkbox" id="nav__toggle">
  <label class="nav__toggle" for="nav__toggle"></label>
  <div class="nav__list">
    <div class="nav__link ">
      <a href="/who-we-are">About Us</a>
    </div>
    <div class="nav__link  ">
      <a href="/agility">Agility</a>
    </div>
    <div class="nav__link  ">
      <a href="/events">Events</a>
    </div>
    <div class="nav__link   current ">
      <a href="/blog">Blog</a>
    </div>
    <div class="nav__link  ">
      <a href="/connect">Connect with Us</a>
    </div>
    <!-- <div class="nav__link nav__cta">
      <a href="/start-a-project" class="btn btn--cta btn--sm">Start a Project</a>
    </div> -->
  </div>
</nav>


    <main>
      <article class="post">
  <section class="section--light">
    

    

    

    

    
      <div class="image-pane image-pane--left image-pane--blog">
        <div class="image-pane__image">
          <img src="/uploads/compilers.gif" />
        </div>
        <div class="image-pane__content">
          <div class="post__title">
            <div class="post__date u-push-bottom--none">17 August 2017</div>
            <h2 class="highlight"><span>Where Would I Even Start?: Compilers </span></h2>
            
              <div class="post__author">
                
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
                <p class="u-push-bottom--none">
                  by 
      Jon Egeland
    
                </p>
              </div>
            
          </div>
        </div>
      </div>
    
  </section>

  <section class="post__body">
    <div>
    <p>Compilers are scary…at least from the outside. On the inside, though, the basics of a compiler are a lot simpler than you may think. A compiler is really just <a href="https://en.wikipedia.org/wiki/Compiler">a program to convert between languages</a>. For example, the <a href="https://babeljs.io/">Babel compiler</a> converts newer versions of JavaScript to older versions that are more compatible with today’s browsers. The things that make larger compilers so menacing are complicated, ambiguous language designs, large standard libraries, and performance optimizations, just to name a few.</p>

<p>In this post, I want to go through the basics of how a compiler works by writing an interpreter for some algebraic expressions. Along the way, I’ll provide references to more detailed material and examples if you want to go more in depth on anything in particular. The final code from this post will all be <a href="https://github.com/faultyserver/compilers-intro">available on GitHub</a> for you to fork. The entire codebase is just over 300 lines.</p>

<p>I’m going to be skipping over a lot of theory in this post, largely because I don’t think it’s necessary in forming a basic understanding of compilers. That said, I would still recommend reading up on the references throughout this post if you’re interested in learning more about compilers in general. The goal here is to provide a quick introduction to give you a basis from which to learn, and a concrete example of some core concepts to work with.</p>

<p>Also, a quick word of warning: this post will breeze through a lot of implementation-specific details. A good understanding of object-oriented programming is recommended. I’m going to be using <a href="https://crystal-lang.org">Crystal</a> as the implementation language, primarily because it is strongly-typed and has first-class enums. These aren’t necessary, but make some parts of lexing and parsing much more concise. If you are familiar with Ruby, Crystal should seem pretty similar.</p>

<p>Lastly, you may have noticed that this post is titled with “compilers”, yet I said we’ll be building an “interpreter”. In reality, we’ll be doing both. First, we’ll take source code and compile it into an in-memory bytecode-like structure, then interpret that structure to execute the code. Overall, that means the project that we’ll be building is an “interpreter that just so happens to have a compiler inside it”, something that is really common for modern languages. Ruby, Python, Lua, and JavaScript are all examples of languages that do some compilation before running as an interpreter. For simplicity, I’ll just be using the word “interpreter” from here on out.</p>

<h2 id="background-and-overview">Background and Overview</h2>

<p>To start building an interpreter, we first need to define what the language looks like. One of the most common syntaxes for doing so is the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backus-Naur Form</a> or EBNF. It provides a clean, consistent way of defining <a href="https://en.wikipedia.org/wiki/Formal_grammar">grammars</a>, or structural definitions of valid syntax. Perhaps more importantly, it’s consistency means there are <a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators">plenty of tools out there</a> to automatically generate parsers given an EBNF input.</p>

<p>For simplicity, we won’t be making use of those tools here, but it’s still useful to look at our language in this EBNF form. So, without further adieu, here it is:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program    ::= statement program | statement
statement  ::= assignment | expr
assignment ::= '@' name '=' expr
expr       ::= term '+' expr | term
term       ::= factor '*' term | factor
factor     ::= '(' expr ')' | number | name
number     ::= [0-9]+
name       ::= [a-z]+
</code></pre></div></div>

<p>In short, each line above represents what’s called a <a href="https://en.wikipedia.org/wiki/Production_(computer_science)"><em>production rule</em></a> or <em>non-terminal</em>. The name of the rule is the left-hand side of the <code class="highlighter-rouge">::=</code> and the right-hand side is the series of productions that make up that rule. A production rule can have alternative definitions separated by the pipe character (<code class="highlighter-rouge">|</code>). For example, the first production rule is called <code class="highlighter-rouge">program</code>, and it consists of either a <code class="highlighter-rouge">statement</code> followed by another <code class="highlighter-rouge">program</code>, or a single <code class="highlighter-rouge">statement</code> with nothing following it.</p>

<p>The alternative to non-terminals are <a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols"><em>terminal symbols</em></a>, and are represented as strings in single quotes, such as <code class="highlighter-rouge">'='</code> and <code class="highlighter-rouge">')'</code> shown above, or regex patterns in the case of <code class="highlighter-rouge">number</code> and <code class="highlighter-rouge">name</code>.</p>

<p>The nice thing about this grammar is that the <a href="https://en.wikipedia.org/wiki/Order_of_operations">order of operations</a> are automatically enforced. In other words, using this grammar ensures that multiplication happens before addition, expressions in parentheses evaluate before multiplication, and so on. As you can imagine, parsing these kinds of expressions is common, so much so that there are specialized <a href="https://en.wikipedia.org/wiki/Operator-precedence_grammar">Operator-precedence grammars and parsers</a> to make their evaluation more efficient. For simplicity, that won’t be covered here, but it’s a worthwhile read nonetheless.</p>

<p>Anyway, enough theory. What kind of statements does this grammar accept? The answer is any basic algebraic expression as well as assignments to variables. Here are some examples:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="vi">@sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="vi">@b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span>
<span class="vi">@c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="vi">@d</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">/</span> <span class="mi">3</span>
</code></pre></div></div>

<p>Just as important are statements that this grammar does <em>not</em> accept. For example, any operator (<code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">=</code>) all need operands on either side and parentheses must be matched. That said, the following are <em>not</em> accepted by this grammar:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b</span> <span class="mi">3</span>
<span class="n">c</span> <span class="o">**</span> <span class="mi">4</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="o">/</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">+</span> <span class="vi">@a</span>
</code></pre></div></div>

<p>Something to note is that these examples all include various whitespace in them. In general, whitespace is ignored when writing EBNFs as it doesn’t affect how the language is parsed. It can sometimes be explicitly brought up to clear up ambiguities, but in this case it isn’t necessary. This will be covered more clearly in the Lexer section later on.</p>

<p>As an exercise, try to figure out what production rules these examples would match or not match according to our EBNF. As a starting point, let’s look at the first statement, <code class="highlighter-rouge">1+1</code>.</p>

<p>We start at <code class="highlighter-rouge">program</code> and see that no matter what, it must start with a <code class="highlighter-rouge">statement</code>, so we check that production rule. <code class="highlighter-rouge">statement</code> can either be an <code class="highlighter-rouge">assignment</code> or an <code class="highlighter-rouge">expr</code>, but an <code class="highlighter-rouge">assignment</code> must start with an <code class="highlighter-rouge">@</code> character, which our example doesn’t have, so we need to look at <code class="highlighter-rouge">expr</code> instead. We can use the same logic to get down to <code class="highlighter-rouge">number</code>, where we finally match the <code class="highlighter-rouge">1</code>. After completing the <code class="highlighter-rouge">number</code> production rule, we retrace our steps back upward to try to match the <code class="highlighter-rouge">+</code>. Looking upward, we’ve finished <code class="highlighter-rouge">factor</code> as well, and the next character is not <code class="highlighter-rouge">*</code>, so <code class="highlighter-rouge">term</code> is also done. Finally, we get back to <code class="highlighter-rouge">expr</code> where we can match the <code class="highlighter-rouge">+</code> and continue on with the first definition.</p>

<hr />

<p>Whew. That was a lot of words. If your eyes glazed over everything above, don’t worry (mine did, too). It’s not <em>really</em> important for just writing an interpreter, but hopefully it will serve as a reference point if anything further on doesn’t make sense.</p>

<p>For the most part, that’s all the theory we’ll need to get into. From here on out, we’ll see more concrete examples and explanations.</p>

<p>In general, interpreters have three phases: Lexing, Parsing, and Interpreting. Going through and implementing these in order, then, means we’ll end up with a working interpreter.</p>

<p>With that out of the way, let’s get building.</p>

<h2 id="lexing">Lexing</h2>

<p>Lexing involves reading a source material character by character, splitting it up into a stream of tokens and classifying each one. I often find this to be the most tedious phase because there aren’t many abstractions to make without sacrificing efficiency. Luckily, with the simple language we’re implementing here, it shouldn’t be <em>too</em> bad.</p>

<p>First up, let’s define a way of classifying tokens. A simple way to do this is with a <code class="highlighter-rouge">TokenType</code> enum.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># token.cr</span>
<span class="n">enum</span> <span class="no">TokenType</span>
  <span class="no">NAME</span>        <span class="c1"># [a-z]+</span>
  <span class="no">NUMBER</span>      <span class="c1"># [0-9]+</span>
  <span class="no">PLUS</span>        <span class="c1"># +</span>
  <span class="no">MINUS</span>       <span class="c1"># -</span>
  <span class="no">STAR</span>        <span class="c1"># *</span>
  <span class="no">SLASH</span>       <span class="c1"># /</span>
  <span class="no">EQUAL</span>       <span class="c1"># =</span>
  <span class="no">LPAREN</span>      <span class="c1"># (</span>
  <span class="no">RPAREN</span>      <span class="c1"># )</span>
  <span class="no">AT</span>          <span class="c1"># @</span>
  <span class="no">WHITESPACE</span>  <span class="c1"># spaces, newlines, tabs, etc.</span>
  <span class="no">EOF</span>         <span class="c1"># End of File character</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Second, we’ll need an object to represent a token, including its type and the exact value it represents. For example, a <code class="highlighter-rouge">NUMBER</code> could be 0, or 1, or 2, and so on.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># token.cr</span>
<span class="k">class</span> <span class="nc">Token</span>
  <span class="n">property</span> <span class="n">type</span> <span class="p">:</span> <span class="no">TokenType</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">EOF</span>
  <span class="n">property</span> <span class="n">value</span> <span class="p">:</span> <span class="no">String</span> <span class="o">=</span> <span class="s2">""</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">value</code> is a <code class="highlighter-rouge">String</code>. Even for <code class="highlighter-rouge">NUMBER</code> tokens, they’re stored as <code class="highlighter-rouge">String</code>s in the lexing phase. We’ll deal with parsing these into numbers during the interpreting phase.</p>

<p>Simple enough; now for the tedious part. For simplicity, let’s assume our input will always be a String. All we need to start creating tokens is to iterate the input and identify or “consume” tokens as they come up. Since we’re in an object-oriented language, let’s wrap this responsibility up in a class. There’s also a little bit of boilerplate here that I’ll try to explain inline.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lexer.cr</span>
<span class="nb">require</span> <span class="s2">"./token.cr"</span>

<span class="k">class</span> <span class="nc">Lexer</span>
  <span class="c1"># The source code being lexed.</span>
  <span class="n">property</span> <span class="n">source</span> <span class="p">:</span> <span class="no">String</span>
  <span class="c1"># The current position in the source String.</span>
  <span class="n">property</span> <span class="n">pos</span> <span class="p">:</span> <span class="no">Int32</span>
  <span class="c1"># The token currently being lexed.</span>
  <span class="n">property</span> <span class="n">current_token</span> <span class="p">:</span> <span class="no">Token</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="vi">@source</span> <span class="p">:</span> <span class="no">String</span><span class="p">)</span>
    <span class="vi">@pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="vi">@current_token</span> <span class="o">=</span> <span class="no">Token</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="c1"># Reset the current token</span>
  <span class="k">def</span> <span class="nf">advance_token</span>
    <span class="vi">@current_token</span> <span class="o">=</span> <span class="no">Token</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="c1"># Scan the source until the next token has been completed and return</span>
  <span class="c1"># that new token.</span>
  <span class="k">def</span> <span class="nf">read_token</span>
    <span class="c1"># We’ll get here next!</span>
  <span class="k">end</span>


  <span class="c1"># Return the character at the current position in the source.</span>
  <span class="c1"># If there is no next character, return an EOF.</span>
  <span class="kp">private</span> <span class="k">def</span> <span class="nf">current_char</span>
    <span class="vi">@source</span><span class="p">[</span><span class="vi">@pos</span><span class="p">]?</span> <span class="o">||</span> <span class="s1">'\0'</span>
  <span class="k">end</span>

  <span class="c1"># Add the current character to the token buffer and advance the</span>
  <span class="c1"># position in the source by one character.</span>
  <span class="kp">private</span> <span class="k">def</span> <span class="nf">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">value</span> <span class="o">+=</span> <span class="n">current_char</span>
    <span class="vi">@pos</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I like to call this a “forgetful” lexer, as it doesn’t keep track of the tokens that have already been parsed. Most interpreters keep a list of lexed tokens to help error reporting and backtracking, but that’s less useful here.</p>

<p>Now, let’s implement <code class="highlighter-rouge">read_token</code>. In our language, most tokens are a single character, and those that aren’t are easily distinguishable. That means the efficient mode of lexing is also clean: we can switch over the current character and deal with multi-character tokens at the end.</p>

<p>With that, the <code class="highlighter-rouge">read_token</code> function can look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lexer.cr</span>
<span class="k">def</span> <span class="nf">read_token</span>
  <span class="c1"># Ensure a clean slate before lexing the next token.</span>
  <span class="n">advance_token</span>

  <span class="c1"># Switch over whatever the current character is.</span>
  <span class="k">case</span> <span class="n">current_char</span>
  <span class="k">when</span> <span class="s1">'\0'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">EOF</span>
  <span class="k">when</span> <span class="s1">'+'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">PLUS</span>
  <span class="k">when</span> <span class="s1">'-'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">MINUS</span>
  <span class="k">when</span> <span class="s1">'*'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">STAR</span>
  <span class="k">when</span> <span class="s1">'/'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">SLASH</span>
  <span class="k">when</span> <span class="s1">'='</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">EQUAL</span>
  <span class="k">when</span> <span class="s1">'('</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">LPAREN</span>
  <span class="k">when</span> <span class="s1">')'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">RPAREN</span>
  <span class="k">when</span> <span class="s1">'@'</span>
    <span class="n">read_char</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">AT</span>
  <span class="k">when</span> <span class="p">.</span><span class="nf">ascii_whitespace?</span>
    <span class="c1"># Keep reading characters as long as they count as whitespace.</span>
    <span class="k">while</span> <span class="n">current_char</span><span class="p">.</span><span class="nf">ascii_whitespace?</span>
      <span class="n">read_char</span>
    <span class="k">end</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">WHITESPACE</span>
  <span class="k">when</span> <span class="p">.</span><span class="nf">ascii_number?</span>
    <span class="c1"># Keep reading characters as long as they are numeric digits.</span>
    <span class="k">while</span> <span class="n">current_char</span><span class="p">.</span><span class="nf">ascii_number?</span>
      <span class="n">read_char</span>
    <span class="k">end</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">NUMBER</span>
  <span class="k">when</span> <span class="p">.</span><span class="nf">ascii_letter?</span>
    <span class="c1"># Keep reading characters as long as they are alphabetic.</span>
    <span class="k">while</span> <span class="n">current_char</span><span class="p">.</span><span class="nf">ascii_letter?</span>
      <span class="n">read_char</span>
    <span class="k">end</span>
    <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">=</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">NAME</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="s2">"Unrecognized character `</span><span class="si">#{</span><span class="n">current_char</span><span class="si">}</span><span class="s2">`."</span>
  <span class="k">end</span>

  <span class="c1"># Return the newly read token</span>
  <span class="c1"># @current_token.value = @buffer.to_s[0..-1]</span>
  <span class="vi">@current_token</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Tedious, right? Thankfully, the <code class="highlighter-rouge">.ascii_*?</code> methods on <code class="highlighter-rouge">Char</code> from the stdlib do a good job of cleaning up conditionals.</p>

<p>In any case, that’s all there is to it! We can test it out by passing in a string and repeatedly calling <code class="highlighter-rouge">next_token</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a new lexer with some source code</span>
<span class="n">lexer</span> <span class="o">=</span> <span class="no">Lexer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"1 + 2 + 3"</span><span class="p">)</span>
<span class="c1"># Read some tokens out</span>
<span class="n">lexer</span><span class="p">.</span><span class="nf">read_token</span> <span class="c1">#=&gt; #&lt;Token:0x... @type=TokenType::NUMBER&gt;</span>
<span class="n">lexer</span><span class="p">.</span><span class="nf">read_token</span> <span class="c1">#=&gt; #&lt;Token:0x... @type=TokenType::WHITESPACE&gt;</span>
<span class="n">lexer</span><span class="p">.</span><span class="nf">read_token</span> <span class="c1">#=&gt; #&lt;Token:0x... @type=TokenType::PLUS&gt;</span>
<span class="c1"># ...</span>
</code></pre></div></div>

<h2 id="parsing">Parsing</h2>

<p>Parsing (often treated as a “superset” of lexing) consumes the token stream generated from lexing and determines the semantic meaning behind them. This is also where the syntactic structure of our language gets enforced. The parser handles for determining whether the source program is valid. If not, it should error out (ideally informing the user <em>why</em> their source is invalid).</p>

<p>The parser’s output also needs to be something that the interpreter can understand. In most cases, this would be an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> or <a href="http://www.nkavvadias.com/hercules/nac-refman.html">N-address code</a>. These are particularly useful as a flexible representation of the meaning of a program. In other words, it’s easy to generate these from one language and then use it to construct a program in a different language with the same meaning.</p>

<p>However, generating and interpreting an AST requires a fair amount of boilerplate, and is really more complex than necessary for our simple language. Instead, we’ll go with a basic Virtual Machine setup and have the parser generate a sequence of instructions to feed into that machine. We’ll get more into how these instructions are handled later on, but for now, we just need a structure to represent them:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># instruction.cr</span>
<span class="n">enum</span> <span class="no">InstructionType</span>
  <span class="no">PUSH</span>
  <span class="no">STORE</span>
  <span class="no">LOAD</span>
  <span class="no">ADD</span>
  <span class="no">SUBTRACT</span>
  <span class="no">MULTIPLY</span>
  <span class="no">DIVIDE</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Instruction</span>
  <span class="n">property</span> <span class="n">type</span> <span class="p">:</span> <span class="no">InstructionType</span>
  <span class="c1"># Arguments that the instruction requires to execute properly.</span>
  <span class="c1"># For example, `PUSH` needs an argument of _what_ to push onto the stack.</span>
  <span class="n">property</span> <span class="n">args</span> <span class="p">:</span> <span class="no">Array</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="vi">@type</span> <span class="p">:</span> <span class="no">InstructionType</span><span class="p">,</span> <span class="vi">@args</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">of</span> <span class="no">String</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, for the parser itself: by treating parsing as a superset of lexing, the <code class="highlighter-rouge">Parser</code> class itself becomes simple. Object-orientation makes this easy, as we can extend the <code class="highlighter-rouge">Lexer</code> class to create a <code class="highlighter-rouge">Parser</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># parser.cr</span>
<span class="nb">require</span> <span class="s2">"./instruction.cr"</span>

<span class="k">class</span> <span class="nc">Parser</span> <span class="o">&lt;</span> <span class="no">Lexer</span>
  <span class="c1"># The list of instructions parsed from the source code. This is what will be fed to the interpreter.</span>
  <span class="n">property</span> <span class="n">instructions</span> <span class="p">:</span> <span class="no">Array</span><span class="p">(</span><span class="no">Instruction</span><span class="p">)</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">of</span> <span class="no">Instruction</span>

  <span class="c1"># Advance through the token stream until a significant token is encountered.</span>
  <span class="c1"># This abstraction allows the rest of the parser to quietly ignore whitespace</span>
  <span class="c1"># and other insignificant tokens.</span>
  <span class="k">def</span> <span class="nf">advance</span>
    <span class="k">while</span> <span class="n">read_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">WHITESPACE</span><span class="p">;</span> <span class="k">end</span>
    <span class="n">current_token</span>
  <span class="k">end</span>

  <span class="c1"># Check if the current token matches the given type and return</span>
  <span class="c1"># truthy if it does. Additionally, if the type matches, automatically</span>
  <span class="c1"># advance to the next significant token.</span>
  <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">type</span> <span class="p">:</span> <span class="no">TokenType</span><span class="p">)</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">current_token</span>
    <span class="k">if</span> <span class="n">current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="n">type</span>
      <span class="n">advance</span>
      <span class="n">token</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Similar to `accept`, but raise an error if the type does not match.</span>
  <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="n">type</span> <span class="p">:</span> <span class="no">TokenType</span><span class="p">)</span>
    <span class="n">accept</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">||</span> <span class="k">raise</span> <span class="s2">"Expected </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2">, got </span><span class="si">#{</span><span class="n">current_token</span><span class="p">.</span><span class="nf">type</span><span class="si">}</span><span class="s2">."</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse_program</span>
    <span class="c1"># Coming up next!</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Hopefully that’s all fairly straightforward and we can dive into the actual parsing. This class takes advantage of the methods defined in <code class="highlighter-rouge">Lexer</code>, so if you see something that’s not defined in <code class="highlighter-rouge">Parser</code>, be sure to check there for the definition.</p>

<p>Finally, we’re ready to start <em>actually</em> parsing. We’ll be implementing what’s known as a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive Descent Parser</a>. In particular, this will be a <a href="https://en.wikipedia.org/wiki/Top-down_parsing">top-down</a>, <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1) parser</a> who’s structure closely resembles the EBNF from earlier and is fairly easy to write out by hand. For reference, here’s that EBNF again:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>program    ::= statement program | statement
statement  ::= assignment | expr
assignment ::= '@' name '=' expr
expr       ::= term '+' expr | term
term       ::= factor '*' term | factor
factor     ::= '(' expr ')' | number | name
number     ::= [0-9]+
name       ::= [a-z]+
</code></pre></div></div>

<p>The basic idea is that we’ll start by parsing a <code class="highlighter-rouge">statement</code>, first trying to parse an <code class="highlighter-rouge">assignment</code>, then trying an <code class="highlighter-rouge">expr</code> if that doesn’t work. To parse an <code class="highlighter-rouge">assignment</code>, we’ll try to parse a <code class="highlighter-rouge">name</code>, then the equals operator, then an <code class="highlighter-rouge">expr</code>. Each production in the EBNF will be it’s own method, so we can just them as <code class="highlighter-rouge">parse_statement</code>, or <code class="highlighter-rouge">parse_term</code>, or <code class="highlighter-rouge">parse_number</code>.</p>

<p>So let’s look at <code class="highlighter-rouge">parse_program</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_program</span>
  <span class="n">advance</span>
  <span class="k">until</span> <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="no">TokenType</span><span class="o">::</span><span class="no">EOF</span>
    <span class="n">parse_statement</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Fairly simple, right? We’re just saying that <code class="highlighter-rouge">program</code> should keep trying to parse <code class="highlighter-rouge">statement</code>s until the source code is reached. The <code class="highlighter-rouge">advance</code> at the beginning just makes sure that any whitespace at the beginning of the program is properly ignored.</p>

<p>But what about <code class="highlighter-rouge">parse_statement</code>? <code class="highlighter-rouge">statement</code> has two <em>different</em> production rules that define it, so we need to look at how they can be differentiated. This is one of the primary concerns in LL grammars: the type of production to be parsed <em>must</em> be able to be determined by the current token in the input. Otherwise, there is ambiguity and it’s hard to know how to continue parsing. (It’s possible to work around this using either backtracking or better lookahead, but those make the parser much more complicated).</p>

<p>In any case, if we look at what makes up a <code class="highlighter-rouge">statement</code>, we can see that an <code class="highlighter-rouge">assignment</code> will always start with an <code class="highlighter-rouge">@</code>, and an <code class="highlighter-rouge">expr</code> never will, so if we check if the current token is an <code class="highlighter-rouge">@</code>, we can decide what production to continue.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_statement</span>
  <span class="k">if</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">AT</span><span class="p">)</span>
    <span class="n">parse_assignment</span>
  <span class="k">else</span>
    <span class="n">parse_expr</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>That’s not too bad! With this example, we’re also seeing how <code class="highlighter-rouge">accept</code> can be used to cleanly show the optional expectation of a token. If we used <code class="highlighter-rouge">expect</code> instead, the parser would raise an error if it didn’t see an <code class="highlighter-rouge">@</code>, which wouldn’t allow the alternative <code class="highlighter-rouge">expr</code> to be considered.</p>

<p>In <code class="highlighter-rouge">parse_assignment</code>, we’ll see our first instruction generation.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_assignment</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">expect</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">NAME</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">EQUAL</span><span class="p">)</span>
  <span class="n">parse_expr</span>
  <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">STORE</span><span class="p">,</span> <span class="p">[</span><span class="nb">name</span><span class="p">.</span><span class="nf">value</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Notice first that we aren’t expecting the <code class="highlighter-rouge">@</code> token. It was already matched and consumed in <code class="highlighter-rouge">parse_statement</code>, so we don’t have to worry about it here. Next, we’re expecting the <code class="highlighter-rouge">NAME</code> token, and then remembering it for later on when we generate the instruction.</p>

<p>The last line is where we actually generate the instruction. It may seem a little odd that we’re just immediately generating and storing the instruction, but that’s one of the nice things about recursive descent parsers. By calling <code class="highlighter-rouge">parse_expr</code>, we can know for sure that the appropriate instructions that need to come <em>before</em> this <code class="highlighter-rouge">STORE</code> instruction will have already been generated.</p>

<p>With the basics in place, I’m going to speed through the other three methods, as they’re mostly identical to each other anyway.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_expr</span>
  <span class="n">parse_term</span>
  <span class="k">if</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">PLUS</span><span class="p">)</span>
    <span class="n">parse_expr</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">ADD</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">MINUS</span><span class="p">)</span>
    <span class="n">parse_expr</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">SUBTRACT</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">parse_term</span>
  <span class="n">parse_factor</span>
  <span class="k">if</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">STAR</span><span class="p">)</span>
    <span class="n">parse_term</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">MULTIPLY</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">SLASH</span><span class="p">)</span>
    <span class="n">parse_term</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">DIVIDE</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">parse_factor</span>
  <span class="k">if</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">LPAREN</span><span class="p">)</span>
    <span class="n">parse_expr</span>
    <span class="n">expect</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">RPAREN</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="nb">name</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">NAME</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">LOAD</span><span class="p">,</span> <span class="p">[</span><span class="nb">name</span><span class="p">.</span><span class="nf">value</span><span class="p">])</span>
  <span class="k">elsif</span> <span class="n">number</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="no">TokenType</span><span class="o">::</span><span class="no">NUMBER</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">&lt;&lt;</span> <span class="no">Instruction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">InstructionType</span><span class="o">::</span><span class="no">PUSH</span><span class="p">,</span> <span class="p">[</span><span class="n">number</span><span class="p">.</span><span class="nf">value</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The only really exciting things here are branching based on the operator. If <code class="highlighter-rouge">accept</code> does <em>not</em> match a token, it <em>does not</em> advance the lexer, so we can use it to check for the existence of a token without worry of messing up the parser’s state. Also notice that the first branch of <code class="highlighter-rouge">parse_factor</code> does <em>not</em> generate an instruction. As mentioned before, calling <code class="highlighter-rouge">parse_expr</code> ensures that all of the needed instructions are generated beforehand, and the parentheses only serve to influence the order of operations (they don’t perform an operation that would need representation as an instruction).</p>

<p>Alright, that took a while, but we made it. We now have a working Lexer and Parser that together generate a series of instructions that can represent any valid program. Let’s try it out real quick:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span> <span class="o">=</span> <span class="no">Parser</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"a = 1 + 2"</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">parse_program</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">instructions</span>
<span class="c1">#=&gt; [Instruction::PUSH(1), Instruction::PUSH(2), Instruction::ADD, Instruction::STORE(a)]</span>
</code></pre></div></div>

<p>Something you may have already noticed, but is likely more apparent here is that what we’ve essentially done is transformed our language that uses infix notation for expressions into <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a> or RPN. While less <em>human</em>-readable, RPN is much simpler for a computer to reason about as there is no chance for ambiguity and can be read from left to right in one pass (no parentheses, order of operations, etc.).</p>

<p>Also notice that we didn’t even have to instantiate a <code class="highlighter-rouge">Lexer</code> here. Because <code class="highlighter-rouge">Parser</code> inherits from <code class="highlighter-rouge">Lexer</code>, that entire phase is hidden from the outside.</p>

<h2 id="interpreting">Interpreting</h2>

<p>Interpreting is where the meaning of the program is realized and executed. Somewhat surprisingly, with all of the ground work laid out in the lexer and parser, this is actually the easiest step. The interpreter just has to take in the instruction list generated by the parser and execute each one in order.</p>

<p>I mentioned previously that we’re using a Virtual Machine design for our interpreter. In particular, we’ll be implementing a <a href="https://en.wikipedia.org/wiki/Stack_machine">Stack Machine</a>. The primary reason for this is that it is extremely easy to reason about if you are familiar with stacks (what goes in last comes out first, etc.). The primary alternative to stack machines are <a href="https://en.wikipedia.org/wiki/Register_machine">Register Machines</a> which are more akin to what the computer you’re on right now uses in its processor. Register machines are much more flexible and allow for <a href="https://en.wikipedia.org/wiki/Instruction_pipelining">Pipelining</a>, which can greatly improve performance, but is far out-of-scope for this introduction.</p>

<p>There isn’t much boilerplate this time, but for consistency I’ll lay out the class structure here first:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># interpreter.cr</span>
<span class="k">class</span> <span class="nc">Interpreter</span>
  <span class="c1"># The 'stack' in our Stack Machine.</span>
  <span class="n">property</span> <span class="n">stack</span> <span class="p">:</span> <span class="no">Array</span><span class="p">(</span><span class="no">Float64</span><span class="p">)</span>
  <span class="c1"># A table of variables and their current values.</span>
  <span class="n">property</span> <span class="n">variables</span> <span class="p">:</span> <span class="no">Hash</span><span class="p">(</span><span class="no">String</span><span class="p">,</span> <span class="no">Float64</span><span class="p">)</span>
  <span class="c1"># The list of instructions to be interpreted.</span>
  <span class="n">property</span> <span class="n">instructions</span> <span class="p">:</span> <span class="no">Array</span><span class="p">(</span><span class="no">Instruction</span><span class="p">)</span>
  
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="vi">@instructions</span> <span class="p">:</span> <span class="no">Array</span><span class="p">(</span><span class="no">Instruction</span><span class="p">))</span>
    <span class="vi">@stack</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">of</span> <span class="no">Float64</span>
    <span class="vi">@variables</span> <span class="o">=</span> <span class="p">{}</span> <span class="n">of</span> <span class="no">String</span> <span class="o">=&gt;</span> <span class="no">Float64</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">run</span>
    <span class="c1"># Coming up next!</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Like I said, not too much boilerplate. One thing to notice is that our stack is built on an array of <code class="highlighter-rouge">Float</code>s. The reason for using <code class="highlighter-rouge">Float</code> instead of <code class="highlighter-rouge">Int</code> is for division, where something like <code class="highlighter-rouge">10 / 4</code> is <code class="highlighter-rouge">2.5</code>, but using an <code class="highlighter-rouge">Int</code> would truncate that to just <code class="highlighter-rouge">2</code>. Even though our language only supports integer inputs, it’s simple enough to support floating-point outputs, so it might as well just work that way from the start.</p>

<p>The other important piece is the <code class="highlighter-rouge">variables</code> property. <code class="highlighter-rouge">variables</code> acts as a <a href="https://en.wikipedia.org/wiki/Symbol_table">Symbol Table</a>, which stores the current value of variables that exist in the program. For example, a program like <code class="highlighter-rouge">a = 1</code> would create an entry <code class="highlighter-rouge">a</code> in <code class="highlighter-rouge">variables</code> with a value of <code class="highlighter-rouge">1</code>.</p>

<p>Now, we come to the final method of the entire project, <code class="highlighter-rouge">run</code>. Interestingly, this method is going to look very similar to <code class="highlighter-rouge">read_token</code> from the lexer, and in a way, that makes sense. All that <code class="highlighter-rouge">run</code> has to do is read the current instruction, perform the appropriate action for it, and repeat, similar to how the Lexer would read a character, perform an action, and repeat. There’s not too much more to explain, so let’s just see what it looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="c1"># Attempt to remove the first element from `instructions`.</span>
  <span class="c1"># Return nil if none exists, thus breaking out of the loop.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">inst</span> <span class="o">=</span> <span class="n">instructions</span><span class="p">.</span><span class="nf">shift?</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">inst</span><span class="p">.</span><span class="nf">type</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">PUSH</span>
      <span class="c1"># PUSH &lt;value&gt;</span>
      <span class="c1"># Push &lt;value&gt; onto the stack.</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="nf">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f64</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">STORE</span>
      <span class="c1"># STORE &lt;name&gt;</span>
      <span class="c1"># Pop the top value from the stack and store it as the variable &lt;name&gt;.</span>
      <span class="vi">@variables</span><span class="p">[</span><span class="n">inst</span><span class="p">.</span><span class="nf">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">LOAD</span>
      <span class="c1"># LOAD &lt;name&gt;</span>
      <span class="c1"># Push the value of the variable &lt;name&gt; onto the stack.</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="vi">@variables</span><span class="p">[</span><span class="n">inst</span><span class="p">.</span><span class="nf">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">ADD</span>
      <span class="c1"># ADD</span>
      <span class="c1"># Pop the two values at the top of the stack, add them together, and push the result.</span>
      <span class="n">b</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="n">a</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">SUBTRACT</span>
      <span class="c1"># SUBTRACT</span>
      <span class="c1"># Pop the two values at the top of the stack, subtract them, and push the result.</span>
      <span class="n">b</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="n">a</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">MULTIPLY</span>
      <span class="c1"># MULTIPLY</span>
      <span class="c1"># Pop the two values at the top of the stack, multiply them, and push the result.</span>
      <span class="n">b</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="n">a</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">InstructionType</span><span class="o">::</span><span class="no">DIVIDE</span>
      <span class="c1"># DIVIDE</span>
      <span class="c1"># Pop the two values at the top of the stack, divide them, and push the result.</span>
      <span class="n">b</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="n">a</span> <span class="o">=</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And that’s it! We now have a working interpreter that executes a series of instructions! The only thing that’s missing is some output to inform the user of the results of their code. Just a little bit of work outside the interpreter can handle that:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"./lexer.cr"</span>
<span class="nb">require</span> <span class="s2">"./parser.cr"</span>
<span class="nb">require</span> <span class="s2">"./interpreter.cr"</span>

<span class="c1"># Parse the source code into instructions.</span>
<span class="n">parser</span> <span class="o">=</span> <span class="no">Parser</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="sx">%q(
  @a = 2 + 2
  @b = 1 + 3 * 3
  @c = b / a
)</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="nf">parse_program</span>

<span class="c1"># Run those instructions.</span>
<span class="n">vm</span> <span class="o">=</span> <span class="no">Interpreter</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="nf">instructions</span><span class="p">)</span>
<span class="n">vm</span><span class="p">.</span><span class="nf">run</span>

<span class="c1"># Output results to the user.</span>
<span class="nb">puts</span> <span class="s2">"Stack contents: </span><span class="si">#{</span><span class="n">vm</span><span class="p">.</span><span class="nf">stack</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"Variables:"</span>
<span class="n">vm</span><span class="p">.</span><span class="nf">variables</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="se">\t</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Running this code should give you the following:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crystal run src/runner.cr
Stack contents: []
Variables:
    a = 4
    b = 10
    c = 2.5
</code></pre></div></div>

<p>Awesome! We now have the complete system working together. The Parser and Lexer work together to compile a series of instructions, then those instructions are fed to the Interpreter to execute the code!</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>That was a <em>whole</em> lot of words and code. This has been a long and winding journey, so if you’ve stuck around, thank you! I hope this post made sense and didn’t scare you off. As I said earlier, there’s a <em>lot</em> of theory that goes into compilers, but I wanted this post to focus more on creating a concrete example that demonstrates the core concepts visually.</p>

<p>If you’re interested in going further, there are plenty of other resources already out there that go through individual concepts in a lot more depth than I’ve laid out here:</p>

<ul>
  <li><strong>Virtual Machines</strong> are commonly explored in blog posts like this one. In fact, the main inspiration for this post was <a href="http://bartoszsypytkowski.com/simple-virtual-machine/">Bartosz Sypytkowski’s Simple Virtual Machine blog post</a>. It’s an excellent look into the more complicated features of a Virtual Machine.</li>
  <li><strong>Parser generators</strong> tend to be more on the academic side, but there are some great resources out there (particularly for <a href="http://dinosaur.compilertools.net/lex/">Lex</a> and <a href="http://dinosaur.compilertools.net/yacc/">Yacc</a>) that go through more advanced lexing and parsing, as well as more of the theory behind them.</li>
  <li><strong>Books on compiler design</strong> aren’t the most accessible way to get into compilers, but if you really want to get serious with them, <a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">The Dragon Book</a> and <a href="https://www.amazon.com/Engineering-Compiler-Second-Keith-Cooper/dp/012088478X/">Engineering a Compiler</a> are some quintessential resources.</li>
  <li><strong>Other introductions:</strong> I’m certainly not the first to write this kind of introduction to writing a compiler. Notable others include <a href="https://compilers.iecc.com/crenshaw/">Jack Crenshaw’s Let’s Build a Compiler</a> (sadly not fully finished, but still a great in-depth resource), and a more modern take, <a href="https://ruslanspivak.com/lsbasi-part1/">Let’s Build a Simple Interpreter by Ruslan Spivak</a>. Both of these go into far more detail than I did here and touch a lot more on theory than anything else. Other projects like the <a href="https://github.com/thejameskyle/the-super-tiny-compiler">Super Tiny Compiler</a> are more similar to this post, but all inlined in the code.</li>
  <li><strong>Other small languages</strong> are also a great way to get in and see a working compiler in action, without being overwhelmed by long histories and complicated designs. While thinking about this post, I looked at <a href="https://github.com/charly-lang/charly">Charly</a>, <a href="https://github.com/tj/luna">Luna</a>, <a href="https://github.com/munificent/wren">wren</a>, and <a href="https://github.com/nim-lang/Nim">Nim</a> among many others for inspiration. I’ll also shamelessly plug my own language, <a href="https://github.com/myst-lang/myst">Myst</a>, where I used the same process laid out in this post as a starting point.</li>
</ul>

<p>There’s a huge world out there and plenty of big projects that can sometimes seem like guarded castles, but I hope that after reading this you’ll be inspired to start hacking on your own compilers and languages.</p>

<p>Designing a language and having to work through all of the things I take for granted when working on other projects has by far been the best learning experience I’ve had in a long time. Not only have I been exposed to the inner workings of the things that make my entire career possible, but I’ve grown a deeper appreciation for the languages I use everyday, seeing the creative thinking and compromises their designers had to make to see their ideas to fruition.</p>

    </div>
    <div class="post__tags">
      <h5>Posted in: </h5>
      <a class="tag" href="/blog/categories/development/index.html">Development</a>
    </div>
  </section>

  <section class="post__related">
    <h3>Related Posts</h3>
    <div class="grid grid--2">
      
      
      

      
        
        

        
          <a href="/blog/refactoring-patterns-in-elixir-replace-conditional-with-polymorphism-via-protocols-part-2" class="card card--feature">
            <div class="card__content">
              <h3>Refactoring Patterns in Elixir: Replace Conditional with Polymorphism Via Protocols Part 2</h3>
              <h4>Zack Kayser</h4>
              <p class="note"></p>
              Read More &rarr;
            </div>
          </a>
          
          
        
      
        
        

        
          <a href="/blog/outsourcing-custom-development-for-fast-paced-companies" class="card card--feature">
            <div class="card__content">
              <h3>Outsourcing Custom Development for Fast-Paced Companies </h3>
              <h4>Peter Kananen</h4>
              <p class="note"></p>
              Read More &rarr;
            </div>
          </a>
          
          
        
      
        
        

        
          <a href="/blog/oh-to-be-a-domain-expert-if-only-we-knew-what-you-know" class="card card--feature">
            <div class="card__content">
              <h3>Oh, to be a Domain Expert … if we only knew what you knew.</h3>
              <h4>Kati Best</h4>
              <p class="note"></p>
              Read More &rarr;
            </div>
          </a>
          
          
        
      
        
        

        
          <a href="/blog/gaslight-your-partner-in-growth" class="card card--feature">
            <div class="card__content">
              <h3>Gaslight, Your Partner in Growth</h3>
              <h4>Steve Hennegan</h4>
              <p class="note"></p>
              Read More &rarr;
            </div>
          </a>
          
          
            
    </div>
  </section>
</article>


<section class="section--light flush">
  <div class="cta">
    <img src="/assets/img/color-shapes-one.svg" class="cta__confetti" />
    <div class="cta__container">
      <div>
        
<h3> Like what you're seeing? Let's keep in touch. </h3> <a href="/newsletter" class="btn btn--cta"> Subscribe to Our Newsletter </a>

      </div>
    </div>
    <img src="/assets/img/color-shapes-two.svg" class="cta__confetti" />
  </div>
</section>


    </main>

    
<footer>
  <div class="footer__container">
    <div class="footer__menu">
      <div href="/" class="footer__logo"></div>
      <h5 class="u-push-bottom--none"><a class="inverse" href="/agility">Agility</a></h5>
      <h5 class="u-push-bottom--none"><a class="inverse" href="/who-we-are">About Us</a></h5>
      <h5 class="u-push-bottom--none"><a class="inverse" href="/events">Events</a></h5>
      <h5 class="u-push-bottom--none"><a class="inverse" href="/blog">Blog</a></h5>
      <h5 class="u-push-bottom--none"><a class="inverse" href="/connect">Contact Us</a></h5>
      <div class="footer__social">
        <a href="https://www.instagram.com/rhythmdogsports/" target="_blank" class="social__link instagram">
  <svg viewBox="0 0 50 50">
    <path d="M16 3C8.83 3 3 8.83 3 16v18c0 7.17 5.83 13 13 13h18c7.17 0 13-5.83 13-13V16c0-7.17-5.83-13-13-13H16zm21 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm-12 3c6.07 0 11 4.93 11 11s-4.93 11-11 11-11-4.93-11-11 4.93-11 11-11zm0 2c-4.96 0-9 4.04-9 9s4.04 9 9 9 9-4.04 9-9-4.04-9-9-9z"/>
  </svg>
</a>
<!-- <a href="http://twitter.com/teamgaslight" target="_blank" class="social__link twitter">
  <svg viewBox="0 0 50 50">
    <path d="M50.06 10.44c-1.85.82-3.83 1.37-5.91 1.62 2.12-1.27 3.76-3.29 4.52-5.69a20.473 20.473 0 0 1-6.53 2.49c-1.88-2-4.55-3.25-7.5-3.25-5.68 0-10.29 4.6-10.29 10.28 0 .8.09 1.59.27 2.34C16.08 17.81 8.5 13.72 3.43 7.5c-.89 1.52-1.39 3.29-1.39 5.17 0 3.57 1.81 6.71 4.57 8.56-1.69-.05-3.27-.52-4.66-1.29v.13c0 4.98 3.55 9.14 8.25 10.09-.86.23-1.77.36-2.71.36-.66 0-1.31-.06-1.94-.19 1.31 4.08 5.11 7.06 9.61 7.14-3.52 2.76-7.95 4.4-12.77 4.4-.83 0-1.65-.05-2.45-.14 4.55 2.92 9.95 4.62 15.76 4.62 18.91 0 29.26-15.67 29.26-29.25 0-.45-.01-.89-.03-1.33 2.01-1.46 3.75-3.27 5.13-5.33z"/>
  </svg>
</a> -->
<a href="http://facebook.com/rhythmdogsports" target="_blank" class="social__link facebook">
  <svg viewBox="0 0 50 50">
    <path d="M41 4H9C6.24 4 4 6.24 4 9v32c0 2.76 2.24 5 5 5h32c2.76 0 5-2.24 5-5V9c0-2.76-2.24-5-5-5zm-4 15h-2c-2.14 0-3 .5-3 2v3h5l-1 5h-4v15h-5V29h-4v-5h4v-3c0-4 2-7 6-7 2.9 0 4 1 4 1v4z"/>
  </svg>
</a>
<!-- <a href="http://github.com/gaslight" target="_blank" class="social__link github">
  <svg viewBox="0 0 50 50">
    <path d="M33 29c-1.8 0-3 1.52-3 4s.89 5.05 3 5c2.22-.05 3.02-2.22 3-5-.02-2.48-1.21-4-3-4zm11.26-11.93c.27-1.34.39-6.1-1.58-11.07 0 0-4.53.5-11.38 5.2-1.43-.4-3.87-.6-6.3-.6s-4.86.2-6.3.59C11.85 6.5 7.32 6 7.32 6c-1.98 4.96-1.88 9.61-1.59 11.07C3.42 19.59 2 22.61 2 26.74 2 44.71 16.91 45 20.67 45h8.66C33.09 45 48 44.71 48 26.74c0-4.13-1.42-7.15-3.74-9.67zM25.14 43H25c-9.43 0-16.84-1.34-16.84-10.5 0-2.2.78-4.23 2.62-5.92 3.07-2.82 8.26-1.33 14.16-1.33h.14c5.89 0 11.09-1.49 14.16 1.33 1.84 1.69 2.61 3.73 2.61 5.92-.01 9.16-7.28 10.5-16.71 10.5zM17 29c-1.79 0-3 2.02-3 4.5s1.21 4.5 3 4.5c1.8 0 3-2.02 3-4.5S18.8 29 17 29z"/>
  </svg>
</a> -->
<!-- <a href="https://www.youtube.com/channel/UCC36CM_uLqhoKEqSy2mjqFQ" target="_blank" class="social__link youtube">
  <svg viewBox="0 0 50 50">
    <path d="M9 4C6.24 4 4 6.24 4 9v32c0 2.76 2.24 5 5 5h32c2.76 0 5-2.24 5-5V9c0-2.76-2.24-5-5-5H9zm6 4h2.4l1.6 4 1.6-4H23l-3 7v4h-2v-4.01c-.6-1.61-2.59-5.98-3-6.99zm10 3c.89 0 1.77.27 2.33.95.43.49.67 1.28.67 2.32v1.46c0 1.04-.2 1.76-.62 2.25-.56.67-1.49 1.02-2.38 1.02s-1.8-.35-2.36-1.02c-.43-.49-.64-1.21-.64-2.25v-1.45c0-1.04.23-1.84.67-2.33.56-.68 1.32-.95 2.33-.95zm4 0h2v6c.05.27.34.39.61.39.41 0 .93-.48 1.39-1.01V11h2v8h-2v-1.38c-.81.79-1.5 1.38-2.41 1.35-.66-.02-1.12-.26-1.35-.74-.14-.28-.24-.73-.24-1.39V11zm-4 1.62c-.14 0-.27.03-.39.08a1.016 1.016 0 0 0-.53.54c-.05.13-.08.26-.08.4v2.81a1.02 1.02 0 0 0 .61.94c.12.05.25.08.39.08s.27-.03.39-.08c.36-.16.61-.52.61-.94v-2.81c0-.56-.45-1.02-1-1.02zM24.99 22h.02s6.71 0 11.19.32c.63.07 1.99.08 3.21 1.33.96.94 1.27 3.1 1.27 3.1s.32 1.53.32 4.06v2.37c0 2.53-.32 4.06-.32 4.06s-.31 2.16-1.27 3.1c-1.22 1.25-2.58 1.26-3.21 1.33-4.48.32-11.2.33-11.2.33s-8.32-.08-10.88-.32c-.71-.13-2.31-.09-3.53-1.33-.96-.95-1.27-3.11-1.27-3.11S9 35.71 9 33.18v-2.37c0-2.53.32-4.06.32-4.06s.31-2.16 1.27-3.1c1.22-1.25 2.58-1.26 3.21-1.33C18.28 22 24.99 22 24.99 22zM12 26v1.98h2V38h2V27.98h2V26h-6zm13 0v12h2v-1.25c.63.78 1.45 1.25 2.12 1.25.75 0 1.41-.4 1.66-1.18.12-.42.21-.81.21-1.7v-2.75c0-.99-.13-1.73-.26-2.15-.24-.78-.85-1.22-1.61-1.22-.98-.01-1.38.5-2.12 1.38V26h-2zm-7 3v6.69c0 .72.1 1.21.23 1.52.22.51.67.79 1.31.79.73 0 1.67-.51 2.46-1.37V38h2v-9h-2v6.27c-.44.58-1.08 1.02-1.48 1.02-.26 0-.47-.11-.52-.4V29h-2zm17.03 0c-1.01 0-1.8.32-2.37.92-.42.44-.66 1.16-.66 2.1v3.07c0 .93.27 1.58.69 2.02.57.6 1.36.9 2.39.9s1.84-.31 2.39-.95c.24-.28.39-.6.46-.95.01-.17.07-.6.07-1.11h-2v.8c0 .46-.45.84-1 .84s-1-.38-1-.84V34h4v-2.03c0-.93-.23-1.62-.64-2.06-.56-.59-1.34-.91-2.33-.91zM35 30.45c.55 0 1 .38 1 .84v1.33h-2v-1.33c0-.47.45-.84 1-.84zm-6.78.3c.55 0 .78.33.78 1.38v2.75c0 1.04-.23 1.4-.78 1.4-.31 0-.9-.21-1.22-.53v-4.38c.32-.31.91-.62 1.22-.62z"/>
  </svg>
</a> -->
<!-- <a href="https://www.linkedin.com/company/gaslight" target="_blank" class="social__link linkedin">
  <svg viewBox="0 0 50 50">
    <path d="M41 4H9C6.24 4 4 6.24 4 9v32c0 2.76 2.24 5 5 5h32c2.76 0 5-2.24 5-5V9c0-2.76-2.24-5-5-5zM17 20v19h-6V20h6zm-6-5.53c0-1.4 1.2-2.47 3-2.47s2.93 1.07 3 2.47c0 1.4-1.12 2.53-3 2.53-1.8 0-3-1.13-3-2.53zM39 39h-6V29c0-2-1-4-3.5-4.04h-.08C27 24.96 26 27.02 26 29v10h-6V20h6v2.56S27.93 20 31.81 20c3.97 0 7.19 2.73 7.19 8.26V39z"/>
  </svg>
</a> -->

      </div>
    </div>
  </div>
</footer>


    <script src="/assets/js/scale.fix.js"></script>
    <script src="/assets/js/rellax.min.js"></script>
    <script>
    var rellax = new Rellax('.float', {
      speed: -2,
      center: false,
      wrapper: null,
      round: true,
      vertical: true,
      horizontal: false
    });
    </script>

    <!-- Start of HubSpot Embed Code -->
    <script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/509988.js"></script>
    <!-- End of HubSpot Embed Code -->

    
  </body>
</html>
